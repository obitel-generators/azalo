require 'rubygems'
require 'nokogiri'
require 'state_machine'

class DocxGenerator

  DocNamecpaces = { 'w' => 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
                    'o' => 'urn:schemas-microsoft-com:office:office',
                    'r' => 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                    'v' => 'urn:schemas-microsoft-com:vml',
                    'w10' => 'urn:schemas-microsoft-com:office:word',
                    'wp' => 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing'}

  attr_accessor :text, :em, :strong, :blockquote_count, :blockquote_paragraph_count

  def initialize
    #StateMachine::Machine.draw('DocxGenerator', :file => 'lib/docx_generator.rb')
    @blockquote_count = 0
    @blockquote_paragraph_count = 0
    super
  end

  def parse_imtermediate_xml(xml)

    Nokogiri::XML::Reader(xml).each do |n|
      #puts "#{n.name} ---> #{n.value} ----> #{n.node_type}"

      event = nil
      unless n.name == 'root'

        if n.node_type == Nokogiri::XML::Reader::TYPE_ELEMENT
          event = (n.name.to_s + '_start').to_sym
        elsif n.node_type == Nokogiri::XML::Reader::TYPE_END_ELEMENT
          event = (n.name.to_s + '_end').to_sym
        elsif n.node_type == Nokogiri::XML::Reader::TYPE_TEXT
          self.text = n.value
          event = :text
        end
        if event
          #puts "event: #{event}"
          #events << "event: #{event}\n"
          fire_state_event(event)
        end
      end
    end
    fire_state_event(:end_of_document)
    return document.to_s

  end

  def foobar
    #puts "xml: >#{xml}<"
    #docx_generator = DocxGenerator.new
    ##events = ''
    #
    #Nokogiri::XML::Reader(xml).each do |n|
    #  puts "#{n.name} ---> #{n.value} ----> #{n.node_type}"
    #
    #  event = nil
    #  next if n.name == 'content'
    #  if n.node_type == Nokogiri::XML::Reader::TYPE_ELEMENT
    #    event = (n.name.to_s + '_start').to_sym
    #  elsif n.node_type == Nokogiri::XML::Reader::TYPE_END_ELEMENT
    #    event = (n.name.to_s + '_end').to_sym
    #  elsif n.node_type == Nokogiri::XML::Reader::TYPE_TEXT
    #    docx_generator.text = n.value
    #    event = :text
    #  end
    #  if event
    #    #puts "event: #{event}"
    #    #events << "event: #{event}\n"
    #    docx_generator.fire_state_event(event)
    #  end
    #end
  end

  def document
    unless @document

      @document = Nokogiri::XML::Document.parse('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
      @document.encoding = 'UTF-8'
      #@document.

      #@document['xmlns:w'] = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
      w_document = Nokogiri::XML::Node.new('w:document', @document)
      @document << w_document
      DocNamecpaces.each_pair do |k, v|
        @document.root.add_namespace(k, v)
      end
      #@document.root.add_namespace('w', 'http://schemas.openxmlformats.org/wordprocessingml/2006/main')
      #@document.root.add_namespace('o', 'urn:schemas-microsoft-com:office:office')
      #@document.root.add_namespace('r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships')
      #@document.root.add_namespace('v', 'urn:schemas-microsoft-com:vml')
      #@document.root.add_namespace('w10', 'urn:schemas-microsoft-com:office:word')
      #@document.root.add_namespace('wp', 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing')

      w_body = Nokogiri::XML::Node.new('w:body', @document)
      w_document << w_body
      @body = w_body
    end
    return @document
  end


  def end_of_document
    @body << (w_sec_ptr << w_type << w_pg_sz << w_pg_mar << w_pg_num_type << w_form_prot << w_text_direction)
  end

  def w_sec_ptr
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    Nokogiri::XML::Node.new('w:sectPr', document)
  end

  def w_type
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    node = Nokogiri::XML::Node.new('w:type', document)
    node['w:val'] = 'nextPage'
    return node
  end

  def w_pg_sz
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    node = Nokogiri::XML::Node.new('w:pgSz', document)
    node['w:h'] = '16838'
    node['w:w'] = '11906'
    return node
  end

  def w_pg_mar
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    node = Nokogiri::XML::Node.new('w:pgMar', document)
    node['w:bottom'] = '1134'
    node['w:footer'] = '0'
    node['w:gutter'] = '0'
    node['w:header'] = '0'
    node['w:left'] = '1134'
    node['w:right'] = '1134'
    node['w:top'] = '1134'
    return node
  end

  def w_pg_num_type
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    node = Nokogiri::XML::Node.new('w:pgNumType', document)
    node['w:fmt'] = 'decimal'
    return node
  end

  def w_form_prot
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    node = Nokogiri::XML::Node.new('w:formProt', document)
    node['w:val'] = 'false'
    return node
  end

  def w_text_direction
    #<w:sectPr>
    #  <w:type w:val="nextPage"/>
    #  <w:pgSz w:h="16838" w:w="11906"/>
    #  <w:pgMar w:bottom="1134" w:footer="0" w:gutter="0" w:header="0" w:left="1134" w:right="1134" w:top="1134"/>
    #  <w:pgNumType w:fmt="decimal"/>
    #  <w:formProt w:val="false"/>
    #  <w:textDirection w:val="lrTb"/>
    #</w:sectPr>
    node = Nokogiri::XML::Node.new('w:textDirection', document)
    node['w:val'] = 'lrTb'
    return node
  end


  def w_p_spacing(before, after)
    #<w:spacing w:after="283" w:before="0"/>
    node = Nokogiri::XML::Node.new('w:spacing', document)
    node['w:before'] = before.to_s
    node['w:after'] = after.to_s
    return node
    #<w:ind w:hanging="0" w:left="567" w:right="567"/>
  end
  def w_p_ind(hanging, left, right)
    #<w:ind w:hanging="0" w:left="567" w:right="567"/>
    node = Nokogiri::XML::Node.new('w:ind', document)
    node['w:hanging'] = hanging.to_s
    node['w:left'] = left.to_s
    node['w:right'] = right.to_s
    return node
  end
  def w_body
    unless @body
      self.document
    end
    return @body
  end

  def w_p_pr
    #<w:pPr>
    node = Nokogiri::XML::Node.new('w:pPr', document)
    return node
  end

  def w_p_style(style)
    # <w:pStyle w:val="style0"/>
    node = Nokogiri::XML::Node.new('w:pStyle', document)
    node['w:val'] = style
    return node
  end

  def w_r
    #<w:r>
    return Nokogiri::XML::Node.new('w:r', document)
  end

  def w_p
    #<w:p>
    Nokogiri::XML::Node.new('w:p', document)
  end


  def w_r_pr
    #<w:rPr/>
    return Nokogiri::XML::Node.new('w:rPr', document)
  end

  def w_t
    #<w:t>  ...  </w:t>
    return Nokogiri::XML::Node.new('w:t', document)
  end

  def w_text(txt)
    return Nokogiri::XML::Text.new(txt, document)
  end

  state_machine :state, :initial => :parked do
    #p caller
    state :parked do
      transition :to => :blockquote_started, :on => :blockquote_start
      transition :to => :p_started, :on => :p_start
      transition :to => :finished, :on => :end_of_document
    end

    state :finished do
      #transition :to => :p_started, :on => :p_start
    end

    state :p_started do
      transition :to => :p_started, :on => [:text, :em_start, :strong_start, :em_end, :strong_end]
      transition :to => :p_ended, :on => :p_end
    end

    state :p_ended do
      transition :to => :p_started, :on => :p_start
      transition :to => :blockquote_ended, :on => :blockquote_end
      transition :to => :finished, :on => :end_of_document
    end

    state :blockquote_started do
      transition :to => :p_started, :on => [:p_start]
      transition :to => :blockquote_ended, :on => :blockquote_end
    end

    state :blockquote_ended do
      transition :to => :p_started, :on => :p_start
      transition :to => :finished, :on => :end_of_document
    end

    #--------------------------------------------------------------------
    event :p_start do
      #puts @text
    end

    event :p_end do
      #puts @text
    end

    event :blockquote_start
    event :blockquote_end

    event :em_start do
      #puts @text
    end

    event :em_end do
      #puts @text
    end

    event :strong_start do
      #puts @text
    end

    event :strong_end do
      #puts @text
    end

    event :text do
      #puts @text
    end

    event :end_of_document do
      #puts @text
    end

    before_transition any => :p_started do |gen, transition|
      if transition.from != transition.to
        if gen.blockquote_count > 0
          gen.blockquote_paragraph_count += 1
          @paragraph = gen.w_p << (gen.w_p_pr << gen.w_p_style('style20'))
        else
          @paragraph = gen.w_p << (gen.w_p_pr << gen.w_p_style('style0'))
        end

        gen.w_body << @paragraph
      end
    end

    before_transition any => :p_ended do |gen, transition|

    end

    before_transition any => :blockquote_started do |gen, transition|
      gen.blockquote_count += 1
    end

    before_transition any => :blockquote_ended do |gen, transition|
      gen.blockquote_count -= 1
      gen.blockquote_paragraph_count = 0

      p_pr = nil
      @paragraph.element_children.each{|e| p_pr = e if e.name == 'w:pPr' }
      if p_pr
        p_pr << gen.w_p_ind(0, 567, 567) << gen.w_p_spacing(0, 283)
      end

    end

    before_transition any => :finished do |gen, transition|
      gen.end_of_document
    end

    #before_transition any => :period_started do |gen, transition|
    #  #vehicle.seatbelt_on = false
    #  puts '<period>'
    #end

    #before_transition any => :period_ended do |gen, transition|
    #  #vehicle.seatbelt_on = false
    #  puts "<period>#{gen.text}</period>"
    #end

    before_transition :on => :text do |gen, transition|
      #puts "gen.text: #{gen.text}"
      if @paragraph
        @paragraph << (gen.w_r << gen.w_r_pr << (gen.w_t << gen.w_text(gen.text)))
      end
      #puts "<period #{gen.em} #{gen.strong}>#{gen.text}</period>"
      #puts "<period>TEXT</period>"
    end

    before_transition :on => :em_start do |gen, transition|
      #puts 'em_start'
      gen.em = 'em'
    end

    before_transition :on => :em_end do |gen, transition|
      #puts 'em_end'
      gen.em = nil
    end

    before_transition :on => :strong_start do |gen, transition|
      #puts 'strong_start'
      gen.strong = 'strong'
    end

    before_transition :on => :strong_end do |gen, transition|
      #puts 'strong_end'
      gen.strong = nil
    end

  end
end
